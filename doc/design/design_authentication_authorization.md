# 認証・認可メカニズムの詳細化

本ドキュメントでは、MultiOllamaAgentCLIシステム全体における認証（Authentication）と認可（Authorization）のメカニズムを詳細に定義する。これにより、システム内のコンポーネント間の安全な通信と、適切なアクセス制御を保証する。

## 1. 認証の目的と原則

### 目的
*   システム内の各コンポーネント（CLI、Agent、MCPサーバー）が、通信相手の正当性を確認する。
*   不正なアクセスや操作を防止する。

### 原則
*   **共有シークレットベース:** 初期実装では、シンプルさとローカル環境での運用を考慮し、共有シークレット（APIキー）を主要な認証メカニズムとする。
*   **セキュアな伝送:** シークレットは、ネットワーク上を平文で流さない。
*   **設定による管理:** シークレットは設定ファイルを通じて安全に管理される。

## 2. 認証メカニズム

### 2.1. Agent間認証

*   **メカニズム:** 各Agentは、他のAgentへのAPIリクエストを行う際に、HTTPヘッダーに共有シークレットを含める。
    *   **ヘッダー名:** `X-Agent-Auth` (仮) または標準的な `Authorization: Bearer <token>`
    *   **値:** 事前に設定された共有シークレット（APIキー）。
*   **検証:** 受信側Agentは、リクエストヘッダーからシークレットを抽出し、自身の設定ファイルに登録されている許可されたシークレットリストと照合する。
*   **設定:** `agent-config.yaml` に `authSecret: string` フィールドを追加し、Agentが自身を認証するためのシークレットを定義する。また、`targetAgents` の各エントリに `authSecret: string` フィールドを追加し、そのAgentと通信するためのシークレットを定義する。

### 2.2. CLI-Agent間認証

*   **メカニズム:** CLIがCoordinator Agentへタスクを送信する際に、HTTPヘッダーに共有シークレットを含める。
    *   **ヘッダー名:** `X-CLI-Auth` (仮) または標準的な `Authorization: Bearer <token>`
    *   **値:** 事前に設定された共有シークレット（APIキー）。
*   **検証:** Coordinator Agentは、リクエストヘッダーからシークレットを抽出し、自身の設定ファイルに登録されている許可されたシークレットと照合する。
*   **設定:** `config.yaml` に `cliAuthSecret: string` フィールドを追加し、CLIがAgentと通信するためのシークレットを定義する。Coordinator Agentの `agent-config.yaml` にも、CLIからの認証を受け入れるためのシークレットを設定する。

### 2.3. MCPサーバー認証

*   **メカニズム:** AgentがMCPサーバーを呼び出す際に、共有シークレットを渡す。
    *   **Stdioトランスポートの場合:** 環境変数またはコマンドライン引数を通じてシークレットを渡す。
    *   **Streamable HTTPトランスポートの場合:** HTTPヘッダーにシークレットを含める。
*   **検証:** MCPサーバーは、受け取ったシークレットを検証する。
*   **設定:** 各MCPサーバーの設定ファイルに、許可されるシークレットを定義する。Agentの `mcpPolicy` にも、各MCPサーバーと通信するためのシークレットを設定する。

## 3. 認可の目的と原則

### 目的
*   認証されたコンポーネントが、特定の操作やリソースへのアクセスを許可されているかを確認する。
*   役割に基づいた適切なアクセス制御を適用する。

### 原則
*   **役割ベースの認可 (RBAC):** Agentの `role` に基づいて、実行可能な操作やアクセス可能なリソースを制限する。
*   **最小権限の原則:** 各コンポーネントには、その機能遂行に必要な最小限の権限のみを与える。

## 4. 認可メカニズム

### 4.1. Agent間認可

*   **ポリシー:** `design_agent_communication.md` で定義されたAPIエンドポイントに対して、Agentの `role` に基づくアクセス制御を適用する。
    *   例: `/tasks` エンドポイントへの `POST` リクエストはCoordinator Agentからのみ許可される。
*   **実装:** 各APIエンドポイントのハンドラー内で、リクエスト元のAgentの認証情報（シークレット）から役割を特定し、その役割が当該操作を許可されているかを確認する。

### 4.2. CLI-Agent間認可

*   **ポリシー:** CLIからのリクエストに対して、Coordinator Agentがその操作を許可するかどうかを判断する。
    *   例: CLIからの特定の管理コマンド（例: `multiollama mcp enable`）は、特定の認証情報を持つCLIからのみ許可される。
*   **実装:** Coordinator AgentのAPIハンドラー内で、CLIの認証情報とリクエスト内容に基づいて認可判断を行う。

### 4.3. MCPサーバー認可

*   **ポリシー:** MCPサーバーが提供するツールに対して、呼び出し元のAgentがそのツールを実行する権限を持つかを確認する。
    *   例: `file_write` ツールは、Developer Agentからのみ許可される、または特定のセキュリティポリシー（`mcpPolicy`）を持つAgentからのみ許可される。
*   **実装:** MCPサーバーのツール実行ハンドラー内で、呼び出し元のAgentの認証情報（シークレット）から役割を特定し、その役割が当該ツールを実行する権限を持つか、または設定されたポリシーに合致するかを確認する。

## 5. セキュリティ考慮事項

*   **シークレットの安全な管理:**
    *   シークレットは、バージョン管理システムに直接コミットせず、環境変数や安全な設定管理ツールを通じて注入する。
    *   ファイルに保存する場合は、適切なファイルパーミッションを設定し、アクセスを制限する。
*   **HTTPSの利用:** すべてのHTTPベースの通信（Agent間、CLI-Agent間、Streamable HTTP MCP）は、本番環境では必ずHTTPSを介して行う。
*   **入力値の検証:** 認証・認可に関わるすべての入力値（シークレット、APIキー、リクエストヘッダーなど）は、厳格に検証し、インジェクション攻撃などを防ぐ。
*   **ログ記録:** 認証失敗、認可拒否などのセキュリティ関連イベントは、詳細なコンテキストとともにログに記録し、監視・監査に利用する。機密情報はログに含めない。
*   **レートリミット:** 認証エンドポイントやAPIエンドポイントに対してレートリミットを適用し、ブルートフォース攻撃を防ぐ。
*   **エラーメッセージ:** 認証・認可エラーのメッセージは、攻撃者にヒントを与えないよう、一般的な内容に留める。

## 6. 今後の拡張

*   **より高度な認証メカニズム:** OAuth 2.0、JWT（JSON Web Token）などの導入を検討し、より柔軟でセキュアな認証を実現する。
*   **集中型認可サービス:** 大規模なシステムになった場合、認可判断を一元的に行うサービス（例: Open Policy Agent）の導入を検討する。
*   **ユーザーベースの認可:** LLMアプリケーションのユーザー単位での認可制御を導入する。
